# Памятка по изменениям: refresh‑токены, ротация, logout и тесты

Этот документ можно использовать как шпаргалку на интервью: что было сделано, зачем и как этим пользоваться.

---

## 1) Что именно было добавлено и изменено (кратко)

Я добавил в проект **refresh‑токены** и их **хранение/ротацию**:

1. **Новая таблица `refresh_tokens`** в базе данных для хранения **хэшей refresh‑токенов** и их статуса (действующий/отозванный).  
2. **JWT‑токены теперь имеют поле `type`** (`access` или `refresh`), чтобы нельзя было перепутать их назначение.  
3. **Новый эндпоинт `/token/refresh`**, который:
   - принимает refresh‑токен;
   - проверяет, что он не отозван;
   - выдаёт новую пару токенов;
   - **отзывает старый refresh‑токен**.
4. **Новый эндпоинт `/logout`**, который отзывает refresh‑токен (выход).
5. **Тесты** для сценария: регистрация → логин → refresh → logout → повторный refresh (должен быть запрещён).
6. В CRUD задач **создание** теперь тоже требует `task.create` (логическая консистентность).

---

## 2) Что изменилось в коде (подробно по файлам)

### `newboock_main/database.py`

#### ✅ Добавлена модель `RefreshToken`
Таблица хранит:
- `token_hash` — хэш refresh‑токена;
- `user_id` — владелец;
- `expires_at` — срок действия;
- `revoked_at` — когда токен был отозван;
- `created_at` — время создания.

Это нужно, чтобы:
1) не хранить сам refresh‑токен в БД;
2) иметь возможность отзывать токены.

---

### `newboock_main/jwt_manager.py`

#### ✅ `type` в JWT
Access и refresh теперь различаются по полю `type`.
Это защищает от ситуации, когда refresh пытаются использовать как access.

#### ✅ Хэширование refresh‑токена
Добавлена функция `hash_refresh_token()`, которая хранит в БД **хэш**, а не сам токен.

#### ✅ Хранение и отзыв
Функции:
- `store_refresh_token(...)` — сохраняет refresh‑токен;
- `revoke_refresh_token(...)` — помечает его отозванным.

---

### `newboock_main/main.py`

#### ✅ Login теперь сохраняет refresh‑токен
После логина refresh‑токен кладётся в таблицу `refresh_tokens`.

#### ✅ Новый `/token/refresh`
Пошагово:
1. Проверяет токен и его тип (`refresh`).
2. Проверяет, что токен **не отозван**.
3. Отзывает старый токен.
4. Выдаёт новую пару токенов.

#### ✅ Новый `/logout`
Просто отзывает refresh‑токен.

#### ✅ `POST /tasks`
Теперь требует `check_permission("task.create")`.

---

### `newboock_main/schemas.py`

Добавлена схема `RefreshRequest`, чтобы принимать refresh‑токен в `/token/refresh` и `/logout`.

---

### `README.md`
В документацию добавлены:
- `/token/refresh`
- `/logout`

---

### `newboock_main/tests/`
Добавлен тест на refresh‑поток:

```
registration -> login -> refresh -> logout -> refresh (401)
```

---

## 3) Как этим пользоваться (примеры)

### 1) Логин
```
POST /login
{
  "email": "user@example.com",
  "password": "password123"
}
```

Ответ:
```
{
  "access_token": "...",
  "refresh_token": "...",
  "token_type": "bearer"
}
```

---

### 2) Обновление токена
```
POST /token/refresh
{
  "refresh_token": "..."
}
```
Ответ — новая пара токенов.

---

### 3) Logout
```
POST /logout
{
  "refresh_token": "..."
}
```
После этого refresh‑токен становится **недействительным**.

---

## 4) Как объяснить на интервью (простыми словами)

**Вопрос HR:** «Зачем refresh‑токены?»  
**Ответ:** Access‑токен живёт недолго, а refresh — дольше. Если access истёк, мы берём refresh и выдаём новый access, не заставляя пользователя логиниться заново.

---

**Вопрос:** «Зачем хранить refresh в БД?»  
**Ответ:** Так можно **отзывать** токены, например при logout или подозрительной активности.

---

**Вопрос:** «Зачем ротация?»  
**Ответ:** При каждом refresh старый токен становится недействительным. Это снижает риск, если кто‑то украл refresh.

---

## 5) Что можно дальше улучшить (если будет время)

1. Добавить миграции Alembic для новой таблицы.
2. Реализовать ограничение на количество активных refresh‑токенов на пользователя.
3. Добавить refresh‑token rotation с device‑id (multi‑device).
4. Убрать `SECRET_KEY` в переменные окружения.
5. Добавить CI + автоматический запуск тестов.

---

**Если хочешь — могу ещё упростить или сократить этот текст под формат “на интервью за 30 секунд”.**
